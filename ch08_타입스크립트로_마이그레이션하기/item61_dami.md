# 아이템 61. 의존성 관계에 따라 모듈 단위로 전환하기

타입스크립트로 마이그레이션을 할 때는 모듈 단위로 진행하는 것이 이상적입니다.

특정 모듈에서 마이그레이션을 진행하는 경우 해당 모듈에 의존성을 가지고 있는 모듈에서 타입 오류가 발생하게 됩니다. 따라서 최하단 모듈부터 작업 후 최상단에 있는 모듈을 마지막으로 완성해야 합니다.

## 마이그레이션 과정

### @types 모듈 설치하기

프로젝트 내 존재하는 모듈은 서드파티 라이브러리에 의존하나 서드파티 라이브러리는 해당 모듈에 의존하지 않기 때문에, 서드파티 라이브러리 타입 모듈을 가장 먼저 설치해야 합니다.

### 외부 API의 타입 정보 추가하기

외부 API의 타입 정보는 특별한 문맥이 없기 때문에 타입스크립트가 추론하기 어렵습니다. 따라서 API 사양 기반으로 타입 정보를 생성해야 합니다.

### 리팩터링 금지

마이그레이션할 때는 타입 정보 추가만 하고, 리팩터링을 해서는 안 됩니다. 당장의 목표는 코드 개선이 아니라 타입스크립트로 전환하는 것임을 명심해야 합니다.

### 선언되지 않은 클래스 멤버 정의하기

자바스크립트는 클래스 멤버 변수를 선언할 필요가 없지만, 타입스크립트에서는 명시적으로 선언해야 합니다. 멤버 변수를 선언하지 않은 클래스가 있는 `.js`파일을 `.ts`로 바꾸면, 참조하는 속성마다 오류가 발생합니다.

타입스크립트로 전환하려는 클래스가 너무 많은 속성을 가지고 있어서 충격 받을지도 모릅니다. 자바스크립트 코드를 타입스크립트로 전환하다 보면 잘못된 설계 그래도 타입스크립트로 전환하는 것은 납득하기 어려울 수 있으나 그 과정에서 리팩터링을 하면 안 됩니다.

### 타입 단언문으로 임시로 타입 에러 해결하기

```typescript
const state = {};
state.name = "New York";
// ~~~ '{}' 유형에 'name' 속성이 없습니다.
state.capital = "Albany";
// ~~~ '{}' 유형에 'capital' 속성이 없습니다.
```

`state` interface 선언 과정에서 임시 방편으로 타입 단언문을 사용할 수 있습니다.

```typescript
interface State {
  name: string;
  capital: string;
}
const state = {} as State;
state.name = "New York"; // 정상
state.capital = "Albany"; // 정상
```

## JSDoc, @ts-check 사용 시 주의사항

자바스크립트 상태에서 `JSDoc`과 `@ts-check`를 사용해 타입 정보를 추가한 상태라면, 타입스크립트로 전환하는 순간 타입 정보가 '무효과' 된다는 것을 주의해야 합니다.

이미 존재하는 `JSDoc`의 타입 정보를 활용해 타입 정보를 생성한 후 불필요해진 `JSDoc`을 제거하면 됩니다.

## 마지막 단계 - 테스트 코드를 타입스크립트로 전환하기

테스트 코드는 항상 의존성 관계도의 최상단에 위치하기에 마이그레이션의 마지막 단계가 되는 것은 자연스러운 일입니다.

또한 최하단 모듈부터 타입스크립트로 전환하는 과정에서 코드, 테스트 코드는 변경되지 않았기 때문에 테스트를 수행할 수 있었을 것입니다.

## 결론

- 서드파티 모듈, 외부 API 호출에 대한 `@types` 추가하기 > 최하단 모듈 부터 마이그레이션
- 리팩터링 금지
