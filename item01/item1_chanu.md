
# TS와 JS 관계 이해하기
  
   JS의 가장 큰 특성은 
   
   - 단일 스레드
   - 비동기 모델

> 브라우저에서 가벼운 처리를 위해 도입한 단일 스레드와 비동기 모델이 단점으로 지적되어 왔지만, 현대의 멀티코어 병렬 프로그래밍 환경에는 적합한 메커니즘으로 인식되는 역설적인 상황이 벌어지고 있습니다.

&nbsp;&nbsp;하지만 단점으로 꼽히는 것이 바로 '**타입 불안정성**' 이다.  이는 JS가 변수를 선언하는 시점에 해당 변수가 어떠한 값을 가질 것인지에 대해서 명시할 필요할 필요가 없기 때문이다. (반면에 정적타이핑 언어인 C++는 변수를 선언하는 시점에 반드시 해당 변수가 가질 값과 타입이 반드시 명시되어야한다.)

&nbsp;&nbsp;TS는 JS가 가진 단점인 '**타입 불안정성**'에 대한 해결책으로, 독보적인 생산성을 가진 JS의 단점을 보완할 수 있는 언어이다. 또한 단순히 TS는  타입 시스템을 제공하는 것 뿐 만 아니라, 전체적인 언어 서비스 모음을 제공하고 있다. 즉, 타이핑만을 위해서 TS를 도입하는 것은 TS를 과소평가하고 있는 것이다.

> 여담으로, 제임스웹 우주망원경에 JS가 들어가 있다고 한다.. ~~어디에나 있다.~~

<br/>

### 그럼 어떤 관계인가?

> TS는 JS의 superset으로, JS를 포함하고 있다.

&nbsp;&nbsp;모든 JS파일은 TS파일로 확장자 변경이 가능하지만, TS파일을 JS파일의 확장자로의 변경은 불가능한 경우가 존재한다. 즉, TS만의 독립적인 문법이 존재한다고 볼 수 있다. 그러나..

<br/>

> 포함관계를 떠나 문법의 유효성과 동작의 이슈는 독립적인 문제이다.

&nbsp;&nbsp;포함관계를 덕분에 JS코드의 TS 마이그레이션은 확장자의 변경 만으로도 가능하다. 물론 JS 문법의 오류가 없더라도 TS의 타입체커에 의해 오류로 검출될 수 있다. 하지만 검출된 오류는 JS의 컴파일과 실행에 전혀 영향을 주지 않는다. 실제로 JS 문법상 오류가 없다면 타입체커가 뱉어내는 오류와 전혀 무관하게 여전히 JS로 컴파일되어 실행 가능하다. '**문법의 유효성과 동작의 이슈는 독립적인 문제**'이기 때문이다. 에러가 에러가 아니면 이거 왜 쓰는데?

<br/>

### 그럼 왜 사용하는가?

> 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다. 

&nbsp;&nbsp;앞에서 TS의 타입 시스템 도입을 통해 JS가 가진 '타입 불안정성'을 해결할 수 있다고 설명하였다. 생각해보자. 컴파일과 실행이 동시에 수행되는 JS의 특성상, 타입오류는 런타임 시점에 잡아낼 수 밖에 없다. 하지만 런타임 시점은 말그대로 코드가 실행되는 시점이기 때문에 실행이 유지되어야하는 프로그램의 경우 매우 위험할 수 있다. 그러므로 런타임 시점에 발생할 수 있는 오류를 미리 차단하는 것이 타입 시스템 도입의 이유이다. 

&nbsp;&nbsp;그러나 아쉽게도 TS가 잠재적으로 발생할 모든 타입 오류를 차단하는 '천라지망'은 아니다. 아까도 말했듯이 TS의 오류는 프로그램의 동작과 전혀 무관하다. 타입 시스템의 타입 체커는 그저 단순히 타이핑 오류에 대한 가이드의 역할만을 수행한다. IDE의 빨간줄은 안고치면 실행했을 때 에러라도 뜨지.. 그럼 타입체커는 사실상 그 것보다 못한 존재인가?

```javascript
const states = [ 
	{name : 'Alabama', capitol : 'Montgomery'}, 
	{name : 'Alaska', capitol : 'Juneau'}, 
	{name : 'Arizona', capitol : 'Phoenix'}, 
] 

for (const state of states) { 
	console.log(state.capital); // 출력값 : undefined
								// ts : capital -> capitol guide
}
```

&nbsp;&nbsp;위의 코드는 JS엔진에 의해 정상적으로 실행되지만, 타입체커는 `state` 배열 원소 객체의 속성명으로 조회할 수 있도록 가이드하고 있다. JS 동작과 전혀 무관하기 때문에 에러로 검출되지 않았으나, 타입체커가 타입오류로 검출해낸 덕에 객체의 속성값을 조회할 수 있도록 수정할 수 있었다. 해당 코드는 동작에 전혀 문제가 되지 않았으나, 우리가 원하는 의도대로 되지 않았을 것이다. 이렇게 **코드의 '동작'과 '의도'를 단일화시키는 역할**을 TS가 수행한다. 

&nbsp;&nbsp;이전 예제가 타입 구문을 추가하지 않고 오로지 TS의 타입체커를 통해서 '동작'과 '의도'를 단일화했다면, 타입 구문을 추가함을 통해 더 명확한 '의도'를 타입체커에게 제공할 수 있다. 실제로 위의 코드에서 `state` 배열 원소 객체의 속성명을 올바르게 가이드 하였으나, 실제 코드의 의도는 `capitol`이 아닌, `capital`을 속성명으로 사용하여 조회하는 것이었다. 아래와 같이 타입 구문을 추가하여 **'동작'과 '의도'를 단일화**할 뿐 만 아니라 **'의도'의 명확화** 또한 가능하게 된다.
  
```typescript
interface State {
	name: string;
	capital: string;	
}

const states : State[] = [ 
	{name : 'Alabama', capitol : 'Montgomery'},  // ts : capitol -> capital guide
	{name : 'Alaska', capitol : 'Juneau'}, 
	{name : 'Arizona', capitol : 'Phoenix'}, 
] 
```
&nbsp;&nbsp;`interface`를 통해 타입구문을 선언하였다. `state` 배열의 객체가 가져야하는 속성을 명시적으로 제공하여 `state` 선언시점에서부터 코드의 '의도'와 다른 부분을 파악할 수 있게 되었다. 그만큼 코드의 '의도'가 명확해졌기 때문에 빠르게 파악할 수 있는 것이다.

<br/>

### 추가적으로 주의할 것은?

> 기본적으로 TS 타입 시스템은 JS의 런타임 동작을 '모델링'한다.

&nbsp;&nbsp;대부분의 경우, TS는 JS의 런타임 동작을 따라간다. 하지만 강제적인 형변환이 발생하는 코드는 타입이 제공하는 '의도'가 모호해지기 때문에 JS가 정상 동작함에도 타입체커가 오류로 가이드할 수 있다. 

```typescript
const a = null + 7; // 7
const b = [] + 12;  // '12'
```

&nbsp;&nbsp;JS는 두 코드 모두 오류로 인식하지 않고 반환값을 제공한다. 이 과정에서 형변환이 발생한다. 만약 형변환을 의도하였다면, TS의 타입 시스템이 가이드하는 오류는 의미가 없다. 그러므로 TS의 사용 목적에 맞게 **최대한 타입이 변경되는 상황을 피하는 것이 좋다**. 즉, TS가 가이드를 잘 할 수 있도록 모호한 부분을 줄여나가는 것이 중요하다는 것을 의미한다.

<br/>

### 정리하자면,  

#### 1. TS는 JS의 superset이지만, TS 문법의 유효성과 JS 동작의 이슈는 독립적인 문제이다.

#### 2.  TS의 타입구문을 통해 '동작'과 '의도'를 단일화 할 뿐 만 아니라 코드가 가진 '의도'를 명확히 할 수 있다.

#### 3. 기본적으로 TS 타입 시스템은 JS의 런타임 동작을 '모델링' 하지만 형변환에 있어서는 최대한 피하는 것이 좋다.


---

<br/>
<br/>

> Written with [StackEdit](https://stackedit.io/).
