# 아이템5 any 타입 지양하기

타입스크립트의 타입 시스템은 점진적(gradual)이고 선택적(optional)이다.

코드에 타입을 조금씩 추가할 수 있어 점진적이고, 언제든지 타입 체커를 해제할 수 있기 때문에 선택적이다.

<br/>

바꿔말하면, 타입을 통해 안정적인 코딩이 가능하도록 제한할 수 있지만, 자유도를 줄 수 있다는건데,

이 기능의 핵심은 `any` 타입이다.

```tsx
let age: number;
age = '12';
// ~~~ '"12"' 형식은 'number' 형식에 할당할 수 없습니다.
age = '12' as any; // OK
```

타입체커는 위와 같은 코드에서 `number` 타입으로 선언된 변수에 `string` 타입을 할당하면 타입오류를 내주는데,

여기서 `as any`를 추가해줌으로써 오류를 해결할 수 있다.

<br/>

이처럼 타입 선언을 추가하기 귀찮거나, 당장 눈앞의 에러를 해결하기 위해 `any` 타입이나 `as any`를 사용하고 싶을 수 있다.

하지만, 이 같은 행위는 특별한 경우가 아니라면 **타입스크립트의 장점을 저버리는 행위**이다. (~~본 repo의 메인 이미지가 딱 이를 풍자하는 짤..~~)

부득이하게 `any`를 사용하더라도 이에 대한 위험성을 인지해야 한다.

<br/>

## any 타입에는 타입 안정성이 없다

위 예제에서 `age`는 `number`타입으로 선언되었지만, `as any`를 사용함으로써 `string`타입을 할당할 수 있게 된다.

이때 타입 체커는 선언된대로 `age`를 `number`로 판단하게 되고, 이는 아래와 같은 부작용을 낳는다.

```tsx
age += 1; // 런타임시 '121'
```

<br/>

## any는 함수 시그니처를 무시해 버린다

타입스크립트에서 함수를 작성할 때는 시그니처를 명시해야 한다.

약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다. 이때 `any`타입을 사용하면 이 약속을 어기게 될 수 있다.

```tsx
function calculateAge(birthDate: Date): number {
  // ...
}
let birthDate: any = '1990-01-19';
calculateAge(birthDate); // 정상
```

위 예시처럼 `birthDate`매개변수는 `string`이 아니라 `Date`타입이어야 하지만, `any`타입을 사용함으로써 이를 무시해버릴 수 있다.

자바스크립트에서 발생하는 암시적 타입변환과 같은 부수효과를 낳을 수 있는 행위들을 제약하기 위해 타입스크립트를 사용하는 것인데, 이와 같은 행위는 **타입스크립트 사용목적에 반대**되는 행동이며, 코드의 문제를 야기할 수 있다.

<br/>

## any 타입에는 언어 서비스가 적용되지 않는다

`any`타입의 심벌을 사용하면 에디터가 속성에 대한 자동완성을 지원해주지 않는다.

또한, 에디터의 `Rename Symbol` 기능을 사용해도 `any`타입으로 선언된 심벌은 적용되지 않는다.

이는 개발 생산성에 있어서 마이너스인 부분이다.

<br/>

## any 타입은 리팩토링시 버그를 감춘다

예를 들어, 아래와 같은 코드가 있을 때

```tsx
interface ComponentProps {
  // 초기 개발 시 타입이 무엇인지 알 수 없어 any로 사용
  onSelectItem: (item: any) => void;
}

function renderSelector(props: ComponentProps) {
  /* ... */
}

let selectedId: number = 0;

function handleSelectItem(item: any) {
  selectedId = item.id;
}

renderSelector({ onSelectItem: handleSelectItem });
```

콜백함수에 실제로는 id만 필요함을 깨닫고

```tsx
interface ComponentProps {
  // id만 필요하여 시그니처 수정
  onSelectItem: (id: number) => void;
}
```

다음과 같이 시그니처를 변경하여도, `handleSelectItem`은 `any`를 매개변수를 받도록 되어 있기 때문에, 타입 체커는 타입 오류를 발견하지 못한다.

이는 런타임시 에러발생으로 이어지게 된다.

<br/>

## any는 타입 설계를 감춰버린다

상태 객체를 정의할 때 무분별하게 `any`타입을 사용해 버린다면, 이는 상태 객체의 설계를 감춰버린다.

깔끔하고 명료한 코드 작성을 위해서는 제대로 된 타입 설계가 필수다.

`any`타입을 지양함으로써 타입 시스템과 타입 체커에 대한 신뢰도가 올라가게 되며, 그렇지 않다면 개발자는 개발을 하면서 타입 오류를 고쳐야 하고, 기존 자바스크립트 사용과 다름없이 머릿속에 실제 타입을 기억해야 한다.

어쩔 수 없이 `any`타입을 사용해야 하는 경우도 있지만, 5장에서 `any`의 단점을 어떻게 보완하는지 자세히 다룬다고 한다.
